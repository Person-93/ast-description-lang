---
source: src/print.rs
assertion_line: 876
expression: printed
input_file: examples/json.ast

---
#![allow(dead_code)]
use super::super::tokens;
pub enum Json {
  Object(Vec<Member>),
  Array(Vec<Json>),
  NumLit(tokens::NumLit),
  StrLit(tokens::StrLit),
  Bool(Bool),
}
pub struct Member {
  pub key: Key,
  pub json: Json,
}
pub enum Key {
  StrLit(tokens::StrLit),
  Ident(tokens::Ident),
}
pub enum Bool {
  KwTrue,
  KwFalse,
}
pub mod parse {
  use super::{super::Error, *};
  use chumsky::prelude::*;
  use tokens::{parse::*, Token};
  pub fn json() -> impl Parser<Token, Json, Error = Error> {
    RECURSIVE.with(|parsers| parsers.borrow().0.clone())
  }
  pub fn object() -> impl Parser<Token, Vec<Member>, Error = Error> {
    member()
      .separated_by(comma())
      .delimited_by(left_brace(), right_brace())
  }
  pub fn member() -> impl Parser<Token, Member, Error = Error> {
    RECURSIVE.with(|parsers| parsers.borrow().2.clone())
  }
  pub fn key() -> impl Parser<Token, Key, Error = Error> {
    str_lit().map(Key::StrLit).or(ident().map(Key::Ident))
  }
  pub fn array() -> impl Parser<Token, Vec<Json>, Error = Error> {
    json()
      .separated_by(comma())
      .delimited_by(left_bracket(), right_bracket())
  }
  pub fn bool() -> impl Parser<Token, Bool, Error = Error> {
    kw_true()
      .map(|_| Bool::KwTrue)
      .or(kw_false().map(|_| Bool::KwFalse))
  }
  thread_local! { static RECURSIVE : std :: cell :: RefCell < (Recursive < 'static , Token , Json , Error > , Recursive < 'static , Token , Vec < Member > , Error > , Recursive < 'static , Token , Member , Error > , Recursive < 'static , Token , Vec < Json > , Error >) > = std :: cell :: RefCell :: new ({ # [allow (unused_assignments)] let mut json = recursive (| _ | todo ()) ; # [allow (unused_assignments)] let mut object = recursive (| _ | todo ()) ; # [allow (unused_assignments)] let mut member = recursive (| _ | todo ()) ; # [allow (unused_assignments)] let mut array = recursive (| _ | todo ()) ; array = recursive (| # [allow (unused_variables)] array | { member = recursive (| # [allow (unused_variables)] member | { object = recursive (| # [allow (unused_variables)] object | { json = recursive (| # [allow (unused_variables)] json | { object . clone () . map (Json :: Object) . or (array . clone () . map (Json :: Array)) . or (num_lit () . map (Json :: NumLit)) . or (str_lit () . map (Json :: StrLit)) . or (kw_true () . map (| _ | Json :: KwTrue) . or (kw_false () . map (| _ | Json :: KwFalse)) . map (Json :: Bool)) }) ; member . clone () . separated_by (comma ()) . delimited_by (left_brace () , right_brace ()) }) ; str_lit () . map (Member :: StrLit) . or (ident () . map (Member :: Ident)) . then (colon ()) json . map (| ((_0 , _1) , _2) | Member { key : _0 , json : _2 }) }) ; json . clone () . separated_by (comma ()) . delimited_by (left_bracket () , right_bracket ()) }) ; (json , object , member , array) }) ; }
}
